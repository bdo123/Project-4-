# -*- coding: utf-8 -*-
"""Testing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DYNGc6NySR9ttsaMXgz7uInpHrDzldsd
"""

from abc import ABC, abstractmethod
from pathlib import Path
import xml.etree.ElementTree as ET
import matplotlib.pyplot as plt
import unittest

# -------------------------
# Helper Functions
# -------------------------

def clean_food_name(name: str) -> str:
    return "".join(ch for ch in name.strip().lower() if ch.isalnum() or ch.isspace())

def format_calories(calories: float) -> str:
    if not isinstance(calories, (int, float)):
        raise TypeError("Calories must be a number")
    return f"{int(calories)} kcal"

def get_macronutrient_ratio(protein: float, carbs: float, fat: float) -> dict:
    total = protein + carbs + fat
    if total == 0:
        return {"protein": 0, "carbs": 0, "fat": 0}
    return {
        "protein": round((protein / total) * 100, 1),
        "carbs": round((carbs / total) * 100, 1),
        "fat": round((fat / total) * 100, 1)
    }

def is_diet_friendly(item: dict, diet_type: str) -> bool:
    diet_type = diet_type.lower()
    if diet_type == "vegetarian":
        return item.get("vegetarian", False)
    if diet_type == "vegan":
        return item.get("vegan", False)
    if diet_type == "gluten-free":
        return item.get("gluten_free", False)
    return False

def generate_food_label(item: dict) -> str:
    return (
        f"{item['name']} - {int(item['calories'])} kcal\n"
        f"Protein: {int(item.get('protein',0))}g | "
        f"Carbs: {int(item.get('carbs',0))}g | "
        f"Fat: {int(item.get('fat',0))}g"
    )

def calculate_total_calories(menu: list[dict]) -> int:
    return sum(item.get("calories", 0) for item in menu)

def filter_menu_by_calories(menu: list[dict], max_cal: int) -> list[dict]:
    return [item for item in menu if item.get("calories", 0) <= max_cal]

def search_menu(menu: list[dict], keyword: str) -> list[dict]:
    keyword = keyword.lower()
    return [item for item in menu if keyword in item["name"].lower()]

def suggest_healthier_alternative(menu: list[dict], selected: str) -> dict:
    selected_item = next((i for i in menu if selected.lower() in i['name'].lower()), None)
    if not selected_item:
        return {}
    selected_cal = selected_item.get("calories", 9999)
    options = [i for i in menu if i.get("calories", 9999) < selected_cal]
    if not options:
        return {}
    return min(options, key=lambda x: x["calories"])

def visualize_nutrition(item: dict, pie_chart=False) -> None:
    labels = ['Protein', 'Carbs', 'Fat']
    values = [item.get('protein',0), item.get('carbs',0), item.get('fat',0)]
    if pie_chart:
        plt.pie(values, labels=labels, autopct='%1.1f%%', startangle=90)
        plt.title(f"Macronutrient Ratio: {item.get('name','Unknown')}")
    else:
        plt.bar(labels, values)
        plt.title(f"Nutrition Breakdown: {item.get('name','Unknown')}")
        plt.ylabel("Grams (g)")
    plt.show()

class FoodItem(ABC):
    def __init__(self, name: str, calories: float, protein=0, carbs=0, fat=0):
        if not isinstance(name, str) or not name.strip():
            raise ValueError("Name must be non-empty string")
        if calories < 0:
            raise ValueError("Calories must be non-negative")
        self._name = name.strip()
        self._calories = float(calories)
        self._protein = float(protein)
        self._carbs = float(carbs)
        self._fat = float(fat)

    @property
    def name(self):
        return self._name

    @property
    def calories(self):
        return self._calories

    @abstractmethod
    def get_nutrition(self):
        pass

    @abstractmethod
    def as_dict(self):
        pass

    def __str__(self):
        return f"{self._name} ({int(self._calories)} kcal)"

class MenuItem(FoodItem):
    def __init__(self, name, calories, protein=0, carbs=0, fat=0,
                 vegetarian=False, vegan=False, gluten_free=False):
        super().__init__(name, calories, protein, carbs, fat)
        self._vegetarian = vegetarian
        self._vegan = vegan
        self._gluten_free = gluten_free
        self._item_id = f"{clean_food_name(name)}-{int(calories)}"

    @property
    def vegetarian(self): return self._vegetarian
    @property
    def vegan(self): return self._vegan
    @property
    def gluten_free(self): return self._gluten_free

    def get_nutrition(self):
        return {
            "name": self._name,
            "calories": self._calories,
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat
        }

    def macronutrient_ratio(self):
        return get_macronutrient_ratio(self._protein, self._carbs, self._fat)

    def is_suitable_for(self, diet):
        return is_diet_friendly({
            "vegetarian": self._vegetarian,
            "vegan": self._vegan,
            "gluten_free": self._gluten_free
        }, diet)

    def generate_label(self):
        return generate_food_label(self.get_nutrition())

    def as_dict(self):
        return {
            "name": self._name,
            "calories": self._calories,
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "vegetarian": self._vegetarian,
            "vegan": self._vegan,
            "gluten_free": self._gluten_free
        }

class DrinkItem(FoodItem):
    def __init__(self, name, calories, protein=0, carbs=0, fat=0, volume_ml=250):
        super().__init__(name, calories, protein, carbs, fat)
        self._volume_ml = volume_ml

    def get_nutrition(self):
        return {
            "name": self._name,
            "calories": self._calories,
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "volume": self._volume_ml
        }

    def generate_label(self):
        return (
            f"{self._name} - {int(self._calories)} kcal\n"
            f"Protein: {int(self._protein)}g | "
            f"Carbs: {int(self._carbs)}g | "
            f"Fat: {int(self._fat)}g | "
            f"Volume: {self._volume_ml} ml"
        )

    def as_dict(self):
        return {
            "name": self._name,
            "calories": self._calories,
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "volume": self._volume_ml,
            "vegetarian": False,
            "vegan": False,
            "gluten_free": False
        }

class Menu:
    def __init__(self, items=None):
        self._items = []
        if items:
            for item in items:
                self.add_item(item)

    @property
    def items(self): return list(self._items)

    def add_item(self, item):
        if not isinstance(item, FoodItem):
            raise TypeError("Item must be a FoodItem")
        if any(i.name.lower() == item.name.lower() for i in self._items):
            raise ValueError("Duplicate item")
        self._items.append(item)

    def remove_item(self, name):
        for i, item in enumerate(self._items):
            if item.name.lower() == name.lower():
                del self._items[i]
                return True
        return False

    def total_calories(self):
        return calculate_total_calories([i.as_dict() for i in self._items])

    def search(self, keyword):
        found = search_menu([i.as_dict() for i in self._items], keyword)
        return [i for i in self._items if i.name.lower() in [f["name"].lower() for f in found]]

    def filter_by_calories(self, max_cal):
        filtered = filter_menu_by_calories([i.as_dict() for i in self._items], max_cal)
        return [i for i in self._items if i.name.lower() in [f["name"].lower() for f in filtered]]

    def filter_by_diet(self, diet_type: str):
        return [item for item in self._items if item.is_suitable_for(diet_type)]

class MenuPersistence:
    @staticmethod
    def save_to_xml(menu: Menu, filename: str):
        root = ET.Element("menu")
        for item in menu.items:
            i = ET.SubElement(root, "item")
            for k,v in item.as_dict().items():
                ET.SubElement(i, k).text = str(v)
        tree = ET.ElementTree(root)
        tree.write(filename, encoding='utf-8', xml_declaration=True)

    @staticmethod
    def load_from_xml(filename: str) -> Menu:
        path = Path(filename)
        if not path.exists():
            raise FileNotFoundError(f"No such file: {filename}")
        tree = ET.parse(filename)
        root = tree.getroot()
        items = []
        for i in root.findall("item"):
            data = {child.tag: child.text for child in i}
            for field in ["calories", "protein", "carbs", "fat"]:
                data[field] = float(data.get(field,0))
            for field in ["vegetarian","vegan","gluten_free"]:
                data[field] = data.get(field,"False")=="True"
            items.append(MenuItem(**data))
        return Menu(items)

class GameDaySummary:
    def __init__(self, menu: Menu):
        self._menu = menu

    def build(self):
        summary = "=== GAME DAY MENU ===\n"
        for item in self._menu.items:
            summary += f"{item.name} - {int(item.calories)} kcal\n"
        return summary

    def save(self, filename):
        with open(filename,"w") as f:
            f.write(self.build())

class SuggestionEngine:
    def __init__(self, menu: Menu):
        self._menu = menu

    def suggest(self, name):
        pick = suggest_healthier_alternative([i.as_dict() for i in self._menu.items], name)
        if not pick:
            return None
        return next((i for i in self._menu.items if i.name == pick["name"]), None)

def interactive_menu(menu: Menu):
    while True:
        print("\nCheck nutrition of a menu item (or type 'exit'):")
        for idx, item in enumerate(menu.items, 1):
            print(f"{idx}. {item.name}")
        choice = input("Enter number: ").strip()
        if choice.lower() == 'exit':
            print("Exiting interactive menu.")
            break
        if not choice.isdigit() or not (1 <= int(choice) <= len(menu.items)):
            print("Invalid selection. Try again.")
            continue
        selected_item = menu.items[int(choice)-1]
        print(selected_item.generate_label())
        visualize_nutrition(selected_item.get_nutrition(), pie_chart=True)

from IPython.display import Image, display
from google.colab import files
import matplotlib.pyplot as plt

def demo():
    print("\n--- GAME DAY MENU DEMO ---\n")

    # Example menu (you can add more items)
    menu = Menu([
        MenuItem("Burger", 450, 25, 40, 20),
        MenuItem("Salad", 120, 3, 10, 7, vegetarian=True, vegan=True),
        MenuItem("Berry Smoothie", 180, 2, 35, 1),
        MenuItem("French Fries", 350, 4, 50, 15),
        MenuItem("Cheese Pizza", 400, 15, 45, 20)
    ])

    # Upload images for menu items
    print("Upload images for your menu items (optional). Any image name works:")
    uploaded_files = files.upload()  # User selects image files
    image_map = {name.lower().replace(" ", ""): fname for name, fname in uploaded_files.items()}

    # Display menu
    print("\n=== GAME DAY MENU ===")
    for i, item in enumerate(menu.items, 1):
        print(f"{i}. {item.name} - {int(item.calories)} kcal")
    print("\n")

    # Suggest healthier alternatives
    sugg_engine = SuggestionEngine(menu)
    for item in menu.items:
        healthier = sugg_engine.suggest(item.name)
        if healthier:
            print(f"Healthier alternative to {item.name}: {healthier.name} ({int(healthier.calories)} kcal)")
    print("\n")

    # Interactive selection loop
    while True:
        print("Check nutrition of a menu item (or type 'exit'):")
        for i, item in enumerate(menu.items, 1):
            print(f"{i}. {item.name}")
        choice = input("Enter number: ").strip()
        if choice.lower() == "exit":
            print("Exiting menu demo.")
            break
        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(menu.items):
            print("Invalid choice. Try again.\n")
            continue

        selected_item = menu.items[int(choice) - 1]
        print("\n" + selected_item.generate_label())

        # Show image if uploaded
        img_key = selected_item.name.lower().replace(" ", "")
        if img_key in image_map:
            display(Image(image_map[img_key]))

        # Visualize nutrition
        item_dict = selected_item.as_dict()
        labels = ['Protein', 'Carbs', 'Fat']
        values = [item_dict['protein'], item_dict['carbs'], item_dict['fat']]
        plt.bar(labels, values, color=['green', 'orange', 'red'])
        plt.title(f"Nutrition Breakdown: {selected_item.name}")
        plt.ylabel("Grams (g)")
        plt.show()
        print("\n")

class TestCapstone(unittest.TestCase):
    def setUp(self):
        self.hotdog = MenuItem("Hot Dog", 300, 12, 20, 15)
        self.salad = MenuItem("Salad", 120, 3, 10, 7, vegetarian=True)
        self.menu = Menu([self.hotdog, self.salad])
        self.summary = GameDaySummary(self.menu)

    def test_menuitem_nutrition(self):
        n = self.hotdog.get_nutrition()
        self.assertEqual(n["calories"], 300)
        self.assertEqual(n["protein"], 12)

    def test_diet_suitability(self):
        self.assertTrue(self.salad.is_suitable_for("vegetarian"))
        self.assertFalse(self.hotdog.is_suitable_for("vegan"))

    def test_menu_add_remove(self):
        burger = MenuItem("Burger", 450, 20, 40, 25)
        self.menu.add_item(burger)
        self.assertIn(burger, self.menu.items)
        self.menu.remove_item("Burger")
        self.assertNotIn(burger, self.menu.items)

    def test_search_filter(self):
        found = self.menu.search("salad")
        self.assertEqual(len(found), 1)
        filtered = self.menu.filter_by_calories(200)
        self.assertEqual(filtered[0].name, "Salad")

    def test_filter_by_diet(self):
        vegetarian_items = self.menu.filter_by_diet("vegetarian")
        self.assertEqual(len(vegetarian_items), 1)
        self.assertEqual(vegetarian_items[0].name, "Salad")
        vegan_items = self.menu.filter_by_diet("vegan")
        self.assertEqual(len(vegan_items), 0)

    def test_save_load_xml(self):
        filename = "test_menu.xml"
        MenuPersistence.save_to_xml(self.menu, filename)
        loaded_menu = MenuPersistence.load_from_xml(filename)
        self.assertEqual(len(loaded_menu.items), 2)
        self.assertEqual(loaded_menu.items[0].name, "Hot Dog")
        Path(filename).unlink()

    def test_summary_build(self):
        output = self.summary.build()
        self.assertIn("Hot Dog", output)
        self.assertIn("Salad", output)

if __name__ == "__main__":
    unittest.main(argv=[''], exit=False)
    demo()