# -*- coding: utf-8 -*-
"""Project 4test - UMD-Gameday-Bites .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kLa7IFtg3crFmm4P6gQx7BgkmViVrgiG
"""

from abc import ABC, abstractmethod

class FoodItem(ABC):
    """Abstract base class for food items."""

    def __init__(self, name, calories, protein=0, carbs=0, fat=0):
        if not isinstance(name, str) or not name.strip():
            raise ValueError("Name must be non-empty string")
        if calories < 0:
            raise ValueError("Calories must be non-negative")
        self._name = name.strip()
        self._calories = float(calories)
        self._protein = float(protein)
        self._carbs = float(carbs)
        self._fat = float(fat)

    @property
    def name(self):
        return self._name

    @property
    def calories(self):
        return self._calories

    @abstractmethod
    def get_nutrition(self):
        """Return the nutritional breakdown for this food item."""
        pass

    def __str__(self):
        return f"{self._name} ({int(self._calories)} kcal)"

class MenuItem(FoodItem):
    """Represents a food item with nutritional profile for Game Day menu."""

    def __init__(self, name, calories, protein=0, carbs=0, fat=0, vegetarian=False, vegan=False, gluten_free=False):
        super().__init__(name, calories, protein, carbs, fat)
        self._vegetarian = vegetarian
        self._vegan = vegan
        self._gluten_free = gluten_free

    def get_nutrition(self):
        return {
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "calories": self._calories
        }

class DrinkItem(FoodItem):
    """Represents a drink item with its own nutritional profile."""

    def __init__(self, name, calories, protein=0, carbs=0, fat=0, volume_ml=250):
        super().__init__(name, calories, protein, carbs, fat)
        self._volume_ml = volume_ml  # Volume of the drink in milliliters

    def get_nutrition(self):
        return {
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "calories": self._calories,
            "volume": self._volume_ml
        }

class Menu:
    """Class to represent a menu containing various food and drink items."""

    def __init__(self, items=None):
        self._items = items if items else []

    def add_item(self, item: FoodItem):
        if not isinstance(item, FoodItem):
            raise TypeError("Item must be an instance of FoodItem or its subclass.")
        self._items.append(item)

    def total_calories(self):
        return sum(item.calories for item in self._items)

    def __str__(self):
        return f"Menu with {len(self._items)} items."

    def __repr__(self):
        return f"Menu({len(self._items)} items)"

def validate_menu_item(name: str, menu: list[str]) -> bool:
    """Check if a food item exists in the menu.

    Args:
        name (str): Food item name to check.
        menu (list[str]): List of valid menu items.

    Returns:
        bool: True if item exists, False otherwise.

    Raises:
        TypeError: If name is not a string
    """
    if not isinstance(name, str):
        raise TypeError("Menu item name must be a string")
    return name.lower().strip() in [item.lower() for item in menu]

def format_calories(calories: int) -> str:
    """Format calories into a readable string.

    Args:
        calories (int): Calorie amount.

    Returns:
        str: Formatted string like "450 kcal".

    Raises:
        TypeError: If calories is not a number
    """
    if not isinstance(calories, (int, float)):
        raise TypeError("Calories must be a number")
    return f"{calories} kcal"

def get_macronutrient_ratio(protein: int, carbs: int, fat: int) -> dict:
    """Return percentage ratio of protein, carbs, and fat.

    Args:
        protein (int): Protein grams.
        carbs (int): Carbohydrate grams.
        fat (int): Fat grams.

    Returns:
        dict: {"protein": %, "carbs": %, "fat": %}
    """
    total = protein + carbs + fat
    if total == 0:
        return {"protein": 0, "carbs": 0, "fat": 0}
    return {
        "protein": round((protein / total) * 100, 1),
        "carbs": round((carbs / total) * 100, 1),
        "fat": round((fat / total) * 100, 1),
    }

def clean_food_name(name: str) -> str:
    """Normalize food names by stripping spaces, symbols, and lowercasing.

    Args:
        name (str): Raw food name.

    Returns:
        str: Cleaned name.
    """
    return "".join(ch for ch in name.strip().lower() if ch.isalnum() or ch.isspace())

def is_diet_friendly(item: dict, diet_type: str) -> bool:
    """Check if a menu item is suitable for a diet type.

    Args:
        item (dict): Item dictionary with attributes
                     (e.g., {"name": "Hot Dog", "vegetarian": False})
        diet_type (str): Type of diet ("vegetarian", "vegan", "gluten-free")

    Returns:
        bool: True if diet-friendly, False otherwise.
    """
    if diet_type.lower() == "vegetarian":
        return item.get("vegetarian", False)
    if diet_type.lower() == "vegan":
        return item.get("vegan", False)
    if diet_type.lower() == "gluten-free":
        return item.get("gluten_free", False)
    return False

"""medium"""

def calculate_total_calories(menu: list[dict]) -> int:
    """Sum total calories from a list of food items.

    Args:
        menu (list[dict]): List of items, each containing a "calories" key.

    Returns:
        int: Total calories of all items.

    Examples:
        >>> menu = [{"name": "Hot Dog", "calories": 300}, {"name": "Fries", "calories": 400}]
        >>> calculate_total_calories(menu)
        700
    """
    return sum(item.get("calories", 0) for item in menu)

def filter_menu_by_calories(menu: list[dict], max_cal: int) -> list[dict]:
    """Filter menu items that are under or equal to a calorie limit.

    Args:
        menu (list[dict]): Menu with nutrition info.
        max_cal (int): Maximum allowed calories.

    Returns:
        list[dict]: Filtered items under calorie threshold.

    Examples:
        >>> menu = [{"name": "Hot Dog", "calories": 300}, {"name": "Burger", "calories": 600}]
        >>> filter_menu_by_calories(menu, 400)
        [{'name': 'Hot Dog', 'calories': 300}]
    """
    return [item for item in menu if item.get("calories", 0) <= max_cal]

def search_menu(menu: list[dict], keyword: str) -> list[dict]:
    """Search menu items by keyword in their name.

    Args:
        menu (list[dict]): List of menu items.
        keyword (str): Search keyword.

    Returns:
        list[dict]: Items that match the keyword.

    Examples:
        >>> menu = [{"name": "Hot Dog"}, {"name": "Cheeseburger"}]
        >>> search_menu(menu, "dog")
        [{'name': 'Hot Dog'}]
    """
    keyword = keyword.lower()
    return [item for item in menu if keyword in item["name"].lower()]

def estimate_serving_size(food_name: str) -> str:
    """Estimate serving size based on the type of food.

    Args:
        food_name (str): Food item name.

    Returns:
        str: Estimated serving size description.

    Examples:
        >>> estimate_serving_size("Cheese Pizza")
        '1 slice'
        >>> estimate_serving_size("French Fries")
        '1 basket'
    """
    food_name = food_name.lower()
    if "pizza" in food_name:
        return "1 slice"
    if "fries" in food_name:
        return "1 basket"
    if "hot dog" in food_name:
        return "1 unit"
    if "pretzel" in food_name:
        return "1 pretzel"
    return "1 serving"

def generate_food_label(item: dict) -> str:
    """Generate a nutrition label string for a food item.

    Args:
        item (dict): Food item with nutrition info
                     (must include 'name' and 'calories').

    Returns:
        str: Formatted label with calories and macros.

    Examples:
        >>> item = {"name": "Hot Dog", "calories": 300, "protein": 12, "carbs": 20, "fat": 15}
        >>> print(generate_food_label(item))
        Hot Dog - 300 kcal
        Protein: 12g | Carbs: 20g | Fat: 15g
    """
    return (
        f"{item['name']} - {item['calories']} kcal\n"
        f"Protein: {item.get('protein', 0)}g | "
        f"Carbs: {item.get('carbs', 0)}g | "
        f"Fat: {item.get('fat', 0)}g"
    )

"""Complex Function"""

import requests

def get_nutrition_from_web(food_name: str) -> dict:
    """Fetch nutrition data for a given food from a web API.

    Args:
        food_name (str): The food name to search (e.g., "Hot Dog").

    Returns:
        dict: Nutrition data (calories, protein, fat, carbs).

    Raises:
        ValueError: If the API cannot find the food.
        ConnectionError: If the request fails.

    Examples:
        >>> get_nutrition_from_web("cheeseburger")
        {'calories': 303, 'protein': 17, 'carbs': 33, 'fat': 12}
    """
    try:
        url = f"https://api.api-ninjas.com/v1/nutrition?query={food_name}"
        headers = {'X-Api-Key': 'YOUR_API_KEY'}
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            raise ConnectionError("Failed to connect to nutrition API.")
        data = response.json()
        if not data:
            raise ValueError("Food not found in database.")
        item = data[0]
        return {
            "calories": round(item.get("calories", 0)),
            "protein": round(item.get("protein_g", 0)),
            "carbs": round(item.get("carbohydrates_total_g", 0)),
            "fat": round(item.get("fat_total_g", 0)),
        }
    except Exception as e:
        print(f"Error fetching nutrition data: {e}")
        return {}

def create_interactive_menu(menu: list[dict]) -> None:
    """Create a text-based interactive food menu for users to browse.

    Args:
        menu (list[dict]): List of food items with names and calories.

    Behavior:
        Displays menu items and lets user select one to view details.

    Examples:
        >>> create_interactive_menu([{"name": "Hot Dog", "calories": 300}])
    """
    print("\n=== UMD Game Day Menu ===")
    for i, item in enumerate(menu, 1):
        print(f"{i}. {item['name']} ({item.get('calories', '?')} kcal)")

    try:
        choice = int(input("\nSelect an item number to view details: "))
        selected = menu[choice - 1]
        print("\n" + generate_food_label(selected))
    except (ValueError, IndexError):
        print("Invalid choice. Please select a valid item.")

import matplotlib.pyplot as plt

def visualize_nutrition(item: dict) -> None:
    """Display a simple bar chart for the nutrition breakdown.

    Args:
        item (dict): Food item with macros (protein, carbs, fat).

    Example:
        >>> visualize_nutrition({'name': 'Hot Dog', 'protein': 12, 'carbs': 20, 'fat': 15})
    """
    labels = ['Protein', 'Carbs', 'Fat']
    values = [item.get('protein', 0), item.get('carbs', 0), item.get('fat', 0)]

    plt.bar(labels, values)
    plt.title(f"Nutrition Breakdown: {item.get('name', 'Unknown')}")
    plt.ylabel("Grams (g)")
    plt.show()

def suggest_healthier_alternative(menu: list[dict], selected: str) -> dict:
    """Suggest a healthier alternative for a selected menu item.

    Args:
        menu (list[dict]): Menu items with calorie info.
        selected (str): Name of the food item.

    Returns:
        dict: Healthier item suggestion, or empty dict if none.

    Example:
        >>> suggest_healthier_alternative(menu, "Cheeseburger")
        {'name': 'Grilled Chicken Sandwich', 'calories': 280}
    """
    selected_item = next((i for i in menu if selected.lower() in i['name'].lower()), None)
    if not selected_item:
        return {}

    selected_cal = selected_item.get("calories", 9999)
    options = [i for i in menu if i.get("calories", 9999) < selected_cal]
    if not options:
        return {}

    return min(options, key=lambda x: x["calories"])

def build_game_day_summary(menu: list[dict]) -> str:
    """Create a formatted summary of all menu items for display or export.

    Args:
        menu (list[dict]): List of food items with nutrition data.

    Returns:
        str: Full printable summary of menu with calories and macros.

    Example:
        >>> print(build_game_day_summary(menu))
    """
    summary = "=== UMD GAME DAY MENU SUMMARY ===\n"
    for item in menu:
        summary += f"\nðŸ” {item['name']} - {item.get('calories', '?')} kcal\n"
        summary += f"Protein: {item.get('protein', 0)}g | Carbs: {item.get('carbs', 0)}g | Fat: {item.get('fat', 0)}g\n"
    return summary

"""CLASS: MenuItem"""

from google.colab import files
uploaded = files.upload()
class MenuItem:
    """Represents a menu item and nutrition profile for Gameday food.

    Args:
        name (str)
        calories (int|float)
        protein, carbs, fat (grams)
        vegetarian, vegan, gluten_free (bools)

    Raises:
        ValueError: invalid inputs

    Example:
        >>> item = MenuItem("Hot Dog", 300, 12, 20, 15)
        >>> print(item)
        Hot Dog (300 kcal)
    """

    def __init__(self, name, calories, protein=0, carbs=0, fat=0,
                 vegetarian=False, vegan=False, gluten_free=False):
        if not isinstance(name, str) or not name.strip():
            raise ValueError("Name must be non-empty string")
        if calories < 0:
            raise ValueError("Calories must be non-negative")

        self._name = name.strip()
        self._calories = float(calories)
        self._protein = float(protein)
        self._carbs = float(carbs)
        self._fat = float(fat)
        self._vegetarian = bool(vegetarian)
        self._vegan = bool(vegan)
        self._gluten_free = bool(gluten_free)

        try:
            clean = p1.clean_food_name(self._name)
            self._item_id = f"{clean}-{int(self._calories)}"
        except:
            self._item_id = f"{self._name.replace(' ','_')}-{int(self._calories)}"

    # Properties
    @property
    def name(self): return self._name

    @property
    def calories(self): return self._calories

    # Integration w/ Project 1 functions
    def format_calories(self):
        try:
            return p1.format_calories(self._calories)
        except:
            return f"{self._calories} kcal"

    def macronutrient_ratio(self):
        return p1.get_macronutrient_ratio(self._protein, self._carbs, self._fat)

    def is_suitable_for(self, diet):
        data = {
            "name": self._name,
            "vegetarian": self._vegetarian,
            "vegan": self._vegan,
            "gluten_free": self._gluten_free
        }
        return p1.is_diet_friendly(data, diet)

    def generate_label(self):
        info = {
            "name": self._name,
            "calories": int(self._calories),
            "protein": int(self._protein),
            "carbs": int(self._carbs),
            "fat": int(self._fat),
        }
        return p1.generate_food_label(info)

    def as_dict(self):
        return {
            "name": self._name,
            "calories": self._calories,
            "protein": self._protein,
            "carbs": self._carbs,
            "fat": self._fat,
            "vegetarian": self._vegetarian,
            "vegan": self._vegan,
            "gluten_free": self._gluten_free,
        }

    def __str__(self):
        return f"{self._name} ({int(self._calories)} kcal)"

    def __repr__(self):
        return f"MenuItem({self._name!r}, {self._calories})"

class Menu:
    """Holds a list of MenuItem objects & runs menu-level operations"""

    def __init__(self, items: Optional[Iterable[MenuItem]] = None):
        self._items = []
        if items:
            for item in items:
                self.add_item(item)

    @property
    def items(self): return list(self._items)

    def add_item(self, item: MenuItem):
        if not isinstance(item, MenuItem):
            raise TypeError("Must be MenuItem")
        if any(i.name.lower() == item.name.lower() for i in self._items):
            raise ValueError("Duplicate item")
        self._items.append(item)

    def remove_item(self, name):
        for i, item in enumerate(self._items):
            if item.name.lower() == name.lower():
                del self._items[i]
                return True
        return False

    # Integration w/ Project 1 functions
    def total_calories(self):
        return p1.calculate_total_calories([i.as_dict() for i in self._items])

    def search(self, keyword):
        found = p1.search_menu([i.as_dict() for i in self._items], keyword)
        names = [i["name"].lower() for i in found]
        return [i for i in self._items if i.name.lower() in names]

    def filter_by_calories(self, max_cal):
        keep = p1.filter_menu_by_calories([i.as_dict() for i in self._items], max_cal)
        names = [i["name"].lower() for i in keep]
        return [i for i in self._items if i.name.lower() in names]

    def __str__(self):
        return f"Menu ({len(self._items)} items)"

    def __repr__(self):
        return f"Menu({len(self._items)} items)"

"""CLASS: NutritionService"""

class NutritionService:
    """Web lookup & nutrition visualization"""

    def __init__(self, use_web=False, fallback=None):
        self._use_web = use_web
        self._fallback = fallback

    def lookup(self, food):
        if not self._use_web and self._fallback:
            return self._fallback(food)
        return p1.get_nutrition_from_web(food)

    def visualize(self, item: MenuItem):
        p1.visualize_nutrition(item.as_dict())

"""CLASS: SuggestionEngine"""

class SuggestionEngine:
    """Suggest healthier menu alternatives"""

    def __init__(self, menu: Menu):
        self._menu = menu

    def suggest(self, name):
        items = [i.as_dict() for i in self._menu.items]
        pick = p1.suggest_healthier_alternative(items, name)
        if not pick: return None
        return next((i for i in self._menu.items if i.name == pick["name"]), None)

"""CLASS: GameDaySummary"""

class GameDaySummary:
    """Generates & saves game day menu summaries"""

    def __init__(self, menu: Menu):
        if not isinstance(menu, Menu):
            raise TypeError("GameDaySummary requires a Menu object")
        self._menu = menu

    def build(self):
        try:
            return p1.build_game_day_summary([i.as_dict() for i in self._menu.items])
        except Exception:
            lines = [f"{i.name} - {i.calories} kcal" for i in self._menu.items]
            return "Game Day Menu:\n" + "\n".join(lines)

    def save(self, filename):
        with open(filename, "w") as f:
            f.write(self.build())

import xml.etree.ElementTree as ET
from pathlib import Path

class MenuPersistence:
    """Handles saving/loading Menu objects to XML."""

    @staticmethod
    def save_to_xml(menu: Menu, filename: str):
        root = ET.Element("menu")
        for item in menu.items:
            i = ET.SubElement(root, "item")
            for k, v in item.as_dict().items():
                ET.SubElement(i, k).text = str(v)
        tree = ET.ElementTree(root)
        tree.write(filename, encoding='utf-8', xml_declaration=True)
        print(f"Menu saved to XML: {filename}")

    @staticmethod
    def load_from_xml(filename: str) -> Menu:
        path = Path(filename)
        if not path.exists():
            raise FileNotFoundError(f"No such file: {filename}")
        tree = ET.parse(filename)
        root = tree.getroot()
        items = []
        for i in root.findall("item"):
            data = {child.tag: child.text for child in i}
            # Convert numeric fields
            for field in ["calories", "protein", "carbs", "fat"]:
                data[field] = float(data.get(field, 0))
            # Convert boolean fields
            for field in ["vegetarian", "vegan", "gluten_free"]:
                data[field] = data.get(field, "False") == "True"
            items.append(MenuItem(**data))
        return Menu(items)

import unittest

class TestGameDayMenu(unittest.TestCase):
    def setUp(self):
        self.item1 = MenuItem("Hot Dog", 300, 12, 20, 15)
        self.item2 = MenuItem("Salad", 120, 3, 10, 7, vegetarian=True)
        self.menu = Menu([self.item1, self.item2])
        self.summary = GameDaySummary(self.menu)
        self.persistence = MenuPersistence()

    def test_add_remove_item(self):
        item3 = MenuItem("Burger", 450, 20, 40, 25)
        self.menu.add_item(item3)
        self.assertIn(item3, self.menu.items)
        self.menu.remove_item("Burger")
        self.assertNotIn(item3, self.menu.items)

    def test_save_load_xml(self):
        filename = "test_menu.xml"
        self.persistence.save_to_xml(self.menu, filename)
        loaded = self.persistence.load_from_xml(filename)
        self.assertEqual(len(loaded.items), 2)
        self.assertEqual(loaded.items[0].name, "Hot Dog")
        Path(filename).unlink()  # cleanup

    def test_summary_build(self):
        output = self.summary.build()
        self.assertIn("Hot Dog", output)
        self.assertIn("Salad", output)

    def test_search_filter(self):
        found = self.menu.search("salad")
        self.assertEqual(len(found), 1)
        filtered = self.menu.filter_by_calories(200)
        self.assertEqual(len(filtered), 1)
        self.assertEqual(filtered[0].name, "Salad")

if __name__ == "__main__":
    unittest.main(argv=[''], exit=False)

"""Example Use"""

item1 = MenuItem("Hot Dog", 300, 12, 20, 15)
item2 = MenuItem("Salad", 120, 3, 10, 7, vegetarian=True)

menu = Menu([item1, item2])
summary = GameDaySummary(menu)

print(summary.build())